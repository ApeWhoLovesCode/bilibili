<template>
  <div id="protect-horse">
    <div class="game-wrap">
      <div class="title">{{title}}</div>
      <div class="canvas-wrap" @click="hiddenTowerOperation">
        <!-- 游戏区域 -->
        <canvas ref="canvasRef" id="mycanvas" width="1050" height="600" @click="getMouse($event)"></canvas>
        <!-- 塔防的容器 -->
        <!-- 上面和左边内边距是 50px -->
        <div v-show="building.isShow" class="building-wrap" :style="buildingStyle">
          <img src="./assets/img/add.png" alt="" class="add-icon">
          <div class="tower-wrap" >
            <div class="tower" v-for="(item, index) in towerList" @click="buildTower(index)">
              <img :src="item.img" alt="" class="tower-icon">
              <div class="info">￥{{item.money}}</div>
            </div>
          </div>
        </div>
        <!-- 塔防的攻击范围 -->
        <div v-show="buildingScope.isShow" class="building-scope" :style="buildingScopeStyle"></div>
        <!-- 终点 -->
        <div class="terminal">
          <div class="hp">{{hp}}</div>
          <img class="terminal-icon" src="./assets/img/horse.png" alt="">
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import SuperGif from './utils/libgif'
export default {
  name: 'protect-horse',
  data() {
    return {
      title: 'game',
      // 浏览器大小变化
      resizeTimer: null,
      // canvas 对象
      canvas: {},
      // canvas 画布距离浏览器左边和顶部的距离
      canvasInfo: {left: 0, top: 0},
      // 得到 canvas 的 2d 上下文
      ctx: {},
      // 设置游戏的暂停
      isPause: true,
      // 等级
      level: 0,
      // 生命值
      hp: 10,
      // 敌人生成间隔时间
      intervalTime: 800, 
      // 存放上一次和本次生成的敌人时间戳，用于暂停判断还有多久产生敌人
      timeDiff: {curTime: 0, stopTime: 0},
      // 生成敌人的定时器
      makeEnemyTimer: null,
      // 暂停后的生成敌人的定时器
      pauseMakeEnemyTimer: null,
      // 当前等级需要的敌人索引
      levelEnemy: [],
      // 场上的敌人数组  
      enemy: [],
      // 偏移量y 是用来计算敌人与地板底部的距离 (两个地板(50*2)-敌人(h(75)+y(15))) = 10
      offset: {y: 10},
      // 敌人资源 curFloorI: 当前所在格的索引, 速度有: 1，2，3，4，6，8，12，24, imgList: gif转静态图片数组
      // ∵ offset.y = 10; ∴ h + y = 90
      enemySource: [
        {x: 0, y: 15, w: 75, h: 75, curFloorI: 0, speed: 2, hp: {cur: 2, sum: 2, size: 8}, type: 'zombies_0', imgSource: require("./assets/img/zombies/zombies_0_move.gif"), imgList: [], imgIndex: 0},
        {x: 0, y: 15, w: 75, h: 75, curFloorI: 0, speed: 2, hp: {cur: 10, sum: 10, size: 8}, type: 'zombies_1', imgSource: require("./assets/img/zombies/zombies_1_move.gif"), imgList: [], imgIndex: 0},
        {x: 0, y: 15, w: 75, h: 75, curFloorI: 0, speed: 2, hp: {cur: 10, sum: 10, size: 8}, type: 'zombies_2', imgSource: require("./assets/img/zombies/zombies_2_move.gif"), imgList: [], imgIndex: 0},
        {x: 0, y: 15, w: 75, h: 75, curFloorI: 0, speed: 3, hp: {cur: 10, sum: 10, size: 8}, type: 'zombies_3', imgSource: require("./assets/img/zombies/zombies_3_move.gif"), imgList: [], imgIndex: 0},
        {x: 0, y: 15, w: 75, h: 75, curFloorI: 0, speed: 3, hp: {cur: 10, sum: 10, size: 8}, type: 'zombies_4', imgSource: require("./assets/img/zombies/zombies_4_move.gif"), imgList: [], imgIndex: 0},
        {x: 0, y: 5,  w: 85, h: 85, curFloorI: 0, speed: 3, hp: {cur: 10, sum: 10, size: 8}, type: 'zombies_5', imgSource: require("./assets/img/zombies/zombies_5_move.gif"), imgList: [], imgIndex: 0},
      ],
      // 最小刻度
      minScale: 2,
      // 所有静态图片资源
      imgObj: {
        floorTile: require("./assets/img/floor-tile.png")
      },
      // 加载完成的静态图片
      imgOnloadObj: null,
      // 格子数量信息 arr: [[ 0:初始值(可以放塔)，1:地板，2:有阻挡物，10(有塔防：10塔防一，11塔防二...) ]]
      gridInfo: { x_num: 21, y_num: 12, size: 50, arr: [[]] },
      // 地板：大小 数量
      floorTile: {size: 50, num: 83},
      // 移动轨迹 [{x坐标, y坐标, x_y(方向): 1:左 2:下 3:右 4:上}]
      movePath: [],
      // 塔防
      building: { left: 0, top: 0, isShow: false },
      // 塔防攻击范围
      buildingScope: {left: 0, top: 0, r: 0, isShow: false},
      // 塔防数据 name:名称, money:花费, r:攻击半径, damage:伤害, rate:攻击速率(n毫秒/次), speed:子弹速度, bSize: 子弹大小, img:塔防图片, bulletImg:子弹图片
      towerList: [
        {name: '茄子茄子', money: 110, r: 300, damage: 1, rate: 1000, speed: 10, bSize: {w:20,h:20}, img: require("./assets/img/plant/qiezi.png"), bulletImg: require("./assets/img/plant/bullet.png")},
        {name: '单发豌豆', money: 110, r: 100, damage: 1, rate: 900, speed: 5, bSize: {w:20,h:20}, img: require("./assets/img/plant/pea_icon.gif"), bulletImg: require("./assets/img/plant/bullet.png")},
        {name: '两发豌豆', money: 110, r: 150, damage: 1, rate: 500, speed: 5, bSize: {w:20,h:20}, img: require("./assets/img/plant/pea_2_icon.gif"), bulletImg: require("./assets/img/plant/bullet.png")},
        {name: '寒冰豌豆', money: 110, r: 150, damage: 1, rate: 900, speed: 5, bSize: {w:20,h:20}, img: require("./assets/img/plant/pea_snow_icon.gif"), bulletImg: require("./assets/img/plant/bullet2.png")},
        {name: '三发豌豆', money: 110, r: 200, damage: 1, rate: 300, speed: 5, bSize: {w:20,h:20}, img: require("./assets/img/plant/pea_3_icon.gif"), bulletImg: require("./assets/img/plant/bullet.png")},
      ],
      // 塔防加载完成图片
      towerOnloadImg: null,
      // 塔防子弹加载完成图片
      towerBulletOnloadImg: null,
      // 场上的防御塔数组 {x, y, targetIndexList(攻击的目标):[], bulletArr(子弹数组)[x,y(子弹当前位置),addX,addY(往目标方向增加的值),xy(当前距离),x_y(目标距离)], ...this.towerList[i], onload-img, onload-bulletImg
      tower: []
    }
  },
  computed: {
    buildingStyle() {
      const {left, top} = this.building
      const size = this.gridInfo.size
      return {left: left + size + 'px', top: top + size + 'px'}
    },
    buildingScopeStyle() {
      const padding = 50
      const size = this.gridInfo.size / 2
      const {left, top, r} = this.buildingScope
      return {left: left + padding + size + 'px', top: top + padding + size + 'px', width: r * 2 + 'px', height: r * 2 + 'px'}
    }
  },
  watch: {
    timeDiff: {
      deep: true,
      handler(val) {
        // 
      }
    },
    // 暂停的判断
    isPause: {
      // immediate: true,
      handler(val) {
        if (val) {
          // 暂停还是有时间差的 bug
          clearTimeout(this.pauseMakeEnemyTimer)
          clearInterval(this.makeEnemyTimer)
          this.timeDiff.stopTime = Date.now()
          // 
        } else {
          this.makeEnemy()
          this.startAnimation();
        }
      }
    },
    // 监听等级变化生成对应敌人
    level: {
      immediate: true,
      handler(val) {
        switch (val) {
          case 0: {
            const list = [0]
            this.levelEnemy = list
            break;
          }
          // case 0: {
          //   const list = [0]
          //   for(let i = 0; i < 8; i++) {
          //     list.push(1)
          //   }
          //   list.push(5)
          //   this.levelEnemy = list
          //   break;
          // }
          case 1: {
            const list = [0]
            for(let i = 0; i < 4; i++) {
              list.push(2)
            }
            for(let i = 0; i < 5; i++) {
              list.push(3)
            }
            this.levelEnemy = list
            break;
          }
          case 2: {
            const list = [0]
            for(let i = 0; i < 5; i++) {
              list.push(4)
            }
            for(let i = 0; i < 5; i++) {
              list.push(5)
            }
            this.levelEnemy = list
            break;
          }
        }
      },
    },
    enemy: {
      deep: true,
      handler(enemyList) {
        const tower = this.tower
        for(let e_i in enemyList) {
          for(let t_i in this.tower) {
            // 进入攻击范围，开始射击 
            if(this.checkValInCircle(enemyList[e_i], tower[t_i])) {
              // 下步---节流立即触发
              if(tower[t_i].timer) return
              tower[t_i].timer = setInterval(() => {
                this.shootBullet(e_i, t_i)
                // this.isPause = true
                clearInterval(tower[t_i].timer)
                tower[t_i].timer = null
              }, tower[t_i].rate);
            }
          }
        }
      }
    }
  },
  mounted() {
    this.init();
    this.getCanvasMargin()
    // 监听浏览器窗口大小变化
    window.addEventListener("resize", this.getCanvasMargin);
  },
  destroyed() {
    window.removeEventListener('resize', this.getCanvasMargin)
  },
  methods: {
    async init() {
      this.canvas = this.$refs.canvasRef;
      this.ctx = this.canvas.getContext("2d");
      this.initAllGrid()
      this.initBuilding()
      this.initMovePath()
      this.onKeyDown()
      await this.allGifToStaticImg()
      // 加载图片
      this.imgOnloadObj = await this.loadImage(this.imgObj);
      this.towerOnloadImg = await this.loadImage(this.towerList, 'img');
      this.towerBulletOnloadImg = await this.loadImage(this.towerList, 'bulletImg');
      this.makeEnemy(true)
      this.startAnimation()
    },
    /** 点击获取鼠标位置 操作塔防 */
    getMouse(e) {
      e.stopPropagation()
      const size = this.gridInfo.size
      const _x = e.x - this.canvasInfo.left, _y = e.y - this.canvasInfo.top
      // 当前点击的格子的索引值
      const col = Math.floor(_y / size), row = Math.floor(_x / size)
      const gridVal = this.gridInfo.arr[col][row]
      const left = row * size, top = col * size
      // 已经有地板或者有建筑了
      if(gridVal >= 10) {
        this.handlerTower(left, top)
      }
      if(gridVal) {
        return
      }
      this.building.isShow = true
      this.building.left = left
      this.building.top = top
    },
    /** 点击建造塔防 */
    buildTower(index) {
      const {left: x, top: y} = this.building
      const size = this.gridInfo.size
      // 每一个塔防数据
      const tower = {x, y, targetIndexList: [], bulletArr: [], ...this.towerList[index], img: this.towerOnloadImg[index], bulletImg: this.towerBulletOnloadImg[index]}
      this.tower.push(tower)
      // 用于标记是哪个塔防 10 + index
      this.gridInfo.arr[y / size][x / size] = 10 + index
      this.drawTower(tower)
    },
    /** 点击背景 隐藏塔防 */
    hiddenTowerOperation() {
      if(this.building.isShow) this.building.isShow = false
      if(this.buildingScope.isShow) this.buildingScope.isShow = false
    },
    /** 处理塔防 */
    handlerTower(x, y) {
      // 当前点击的是哪个塔防
      const tower = this.tower.find(item => item.x === x && item.y === y)
      const {x:left, y:top, r} = tower
      // 展示攻击范围
      this.buildingScope = {isShow: true, left, top, r}
      // this.drawAttackScope(tower)
    },
    /** 发射子弹  enemy:敌人索引，t_i:塔索引 */
    shootBullet(e_i, t_i) {
      if(!this.enemy[e_i]) return
      const {x, y, w, h} = this.enemy[e_i]
      // 敌人中心坐标
      const _x = x + w / 2, _y = y + h / 2
      const {x: t_x, y: t_y, speed } = this.tower[t_i]
      const size_2 = this.gridInfo.size / 2
      // 子弹初始坐标
      const begin = {x: t_x + size_2, y: t_y + size_2}
      // 两坐标间的差值
      const diff = {x: _x - begin.x, y: _y - begin.y}
      // 子弹和敌人的距离
      const distance = this.powAndSqrt(diff.x, diff.y)
      const addX = speed * diff.x / distance, addY = speed * diff.y / distance
      const bullet = {x: begin.x, y: begin.y, _x, _y, addX, addY, xy: 0, x_y: distance}
      this.tower[t_i].bulletArr.push(bullet)
      // 添加攻击目标的索引
      this.tower[t_i].targetIndexList = [e_i]
    },
    /** 开启动画绘画 */
    startAnimation() {
      const that = this;
      (function go() {
        that.startDraw();
        if (!that.isPause) {
          // 时间间隔为 1000/60 每秒 60 帧
          requestAnimationFrame(go);
        }
      })();
    },
    /** 开始绘画 */
    startDraw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.drawFloorTile()
      this.drawTower()
      this.drawAndMoveBullet()
      // 循环静态图片画敌人
      for(let index = 0; index < this.enemy.length; index++) {
        const item = this.enemy[index]
        const res = this.moveEnemy(index)
        // 当敌人已经到达终点，后面就不执行了
        if(res) break
        this.drawEnemy(index)
        if(item.imgIndex === item.imgList.length - 1) this.enemy[index].imgIndex = 0
        else this.enemy[index].imgIndex++
      }
    },
    /** 画地板 */
    drawFloorTile() {
      const size = this.gridInfo.size
      for(let f of this.movePath) {
        this.ctx.drawImage(this.imgOnloadObj.floorTile, f.x, f.y, size, size)
      }
    },
    /** 画塔防 */
    drawTower(item) {
      const size = this.gridInfo.size
      if(item) {
        this.ctx.drawImage(item.img, item.x, item.y, size, size)
      } else {
        for(const t of this.tower) {
          this.ctx.drawImage(t.img, t.x, t.y, size, size)
        }
      }
    },
    /** 画并处理子弹 */
    drawAndMoveBullet() {
      for(const t of this.tower) {
        for(const b_i in t.bulletArr) {
          const {w, h} = t.bSize
          const {x, y, addX, addY, x_y} = t.bulletArr[b_i]
          this.ctx.drawImage(t.bulletImg, x - w / 2, y - h / 2, w, h)
          t.bulletArr[b_i].x += addX
          t.bulletArr[b_i].y += addY
          t.bulletArr[b_i].xy += t.speed
          // 子弹击中敌人
          if(t.bulletArr[b_i].xy >= x_y) {
            // 清除子弹
            t.bulletArr.splice(b_i, 1)
            // 敌人扣血
            for(const index of t.targetIndexList) {
              this.enemy[index].hp.cur -= t.damage
              // 消灭敌人
              if(this.enemy[index].hp.cur <= 0) {
                this.enemy.splice(index, 1)
              }
            }
          }
        }
      }
    },
    /** 画攻击范围 */
    drawAttackScope(tower) {
      if(!tower) return
      const size_2 = this.gridInfo.size / 2
      const {r, x, y} = tower
      // arc (x, y, 半径, 0, 0到 2 * Math.PI 弧度, ture(逆时针))
      // this.ctx.beginPath()
      this.ctx.arc(x + size_2, y + size_2, r, 0, 2 * Math.PI, false)
      this.ctx.lineWidth = 2
      this.ctx.strokeStyle = '#282c34'
      this.ctx.stroke()
    },
    /** 画敌人 */
    drawEnemy(index) {
      if(!this.enemy[index]) return
      const { x, y, w, h, imgList, imgIndex, hp } = this.enemy[index]
      // this.ctx.translate(200, 0);
      // this.ctx.scale(-1, 1)

      this.ctx.drawImage(imgList[imgIndex], x, y, w, h) 
      
      if(hp.cur === hp.sum) return
      // 绘画生命值
      const w_2 = w - hp.size
      this.ctx.fillStyle = '#0066a1'
      this.ctx.fillRect(x, y - hp.size, w_2, hp.size)
      this.ctx.fillStyle = '#49ca00'
      this.ctx.fillRect(x, y - hp.size,  w_2 * hp.cur / hp.sum, hp.size)
      // 画边框
      this.ctx.beginPath();
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#cff1d3"; //边框颜色
      this.ctx.rect(x, y - hp.size, w_2, hp.size);  //透明无填充
      this.ctx.stroke();
    },
    /** 敌人移动 */
    moveEnemy(index) {
      const { w, h, speed, curFloorI } = this.enemy[index]
      // 敌人到达终点
      if(curFloorI === this.floorTile.num - 1) {
        this.enemy.splice(index, 1)
        // 最后一只怪物消失了
        if(index === 0 && this.enemy.length === 1) {
          this.level++
          this.parse = true
          this.makeEnemy()
        }
        return true
      }
      const size = this.gridInfo.size
      // 将格子坐标同步到敌人的坐标
      const { x, y, x_y } = this.movePath[curFloorI]
      // const _y = y - (size - this.offset.y)
      const _y = y - (size - (size * 2 - h - this.offset.y))
      // 敌人需要站在地板中间区域
      const _x = x - (w - size)
      switch (x_y) {
        case 1: this.enemy[index].x -= speed; break;
        case 2: this.enemy[index].y -= speed; break;
        case 3: this.enemy[index].x += speed; break;
        case 4: this.enemy[index].y += speed; break;
      }
      const { x: eX, y: eY } = this.enemy[index]
      // if(eX === _x && eY === _y) {
      if((eX >= _x &&  eX <= _x + speed) && (eY >= _y &&  eY <= _y + speed)) {
        this.enemy[index].curFloorI++
      }
    },
    /** 按间隔时间生成敌人 */
    makeEnemy(isInit) {
      // 当前关卡敌人已经全部上场
      if(this.enemy.length === this.levelEnemy.length) return
      // 刚开始生成了一个敌人 然后因为是暂停，所以会清除定时器
      if(isInit) {
        this.timeDiff.stopTime = Date.now()
        this.setEnemy()
        return
      }
      // 暂停回来，间隔时间修改
      const time = this.intervalTime - (this.timeDiff.stopTime - this.timeDiff.curTime)
      // 
      this.pauseMakeEnemyTimer = setTimeout(() => {
        this.setEnemy()
        this.makeEnemyTimer = setInterval(() => {
          if(this.enemy.length === this.levelEnemy.length || this.isPause) {
            clearInterval(this.makeEnemyTimer)
          } else {
            this.setEnemy()
          }
        }, this.intervalTime)
      }, time)
    },
    /** 生成敌人 */
    setEnemy() {
      this.timeDiff.curTime = Date.now()
      this.enemy.push(this.$lodash.cloneDeep(this.enemySource[this.levelEnemy[this.enemy.length]]))
    },
    /** 初始化所有格子 */
    initAllGrid() {
      const { x_num, y_num } = this.gridInfo
      const arr = []
      for(let i = 0; i < x_num; i++) {
        arr.push([])
        for(let j = 0; j < y_num; j++) {
          arr[i][j] = 0
        }
      }
      this.gridInfo.arr = arr
    },
    /** 初始化塔防 */
    initBuilding() {

    },
    /** 初始化行动轨迹 */
    initMovePath() {
      const size = this.gridInfo.size
      // 刚开始就右移了，所有该初始格不会算上去
      const movePathItem = {x: 0, y: 50, x_y: 3}
      const movePath = []
      // 控制x y轴的方向 1:左 2:下 3:右 4:上
      let x_y = 3
      for(let i = 0; i < this.floorTile.num; i++) {
        switch (i) {
          // 上 
          case 3: case 15: case 21: case 39: case 58: case 68: {
            x_y = 4; break;
          }
          // 右
          case 5: case 10: case 23: case 34: case 77: {
            x_y = 3; break;
          } 
          // 下
          case 8: case 29: case 51: case 62: case 74: case 79: {
            x_y = 2; break;
          } 
          // 左
          case 18: case 48: case 53: case 60: case 64: case 70: case 81: {
            x_y = 1; break;
          } 
        }
        if(x_y % 2) movePathItem.x += x_y === 3 ? size : -size
        else movePathItem.y += x_y === 4 ? size : -size
        movePathItem.x_y = x_y
        movePath.push(JSON.parse(JSON.stringify(movePathItem)))
        this.gridInfo.arr[movePathItem.y/size][movePathItem.x/size] = 1
      }
      this.movePath = movePath
    },
    /** 获取canvas与浏览器 左边 / 顶部 的距离 */
    getCanvasMargin() {
      clearTimeout(this.resizeTimer)
      this.resizeTimer = setTimeout(() => {
        this.canvasInfo.left = this.$refs.canvasRef.getBoundingClientRect().left;
        this.canvasInfo.top = this.$refs.canvasRef.getBoundingClientRect().top;
      }, 50);
    },
    /** 判断值是否在圆内 */
    checkValInCircle(enemy, tower) {
      const {x, y, w, h} = enemy
      const angleList = [
        this.calculateDistance(tower, x, y),
        this.calculateDistance(tower, x + w, y),
        this.calculateDistance(tower, x + w, y + h),
        this.calculateDistance(tower, x , y + h),
      ]
      if(angleList.some(item => item <= tower.r)) {
        return true
      }
      return false
    },
    /** 计算点到圆心的距离之间的距离 */
    calculateDistance(tower, x, y) {
      const {x: _x, y: _y} = tower
      const size_2 = this.gridInfo.size / 2
      return this.powAndSqrt(_x + size_2 - x, _y + size_2 - y)
    },
    /** 两值平方相加并开方 求斜边 */
    powAndSqrt(val1, val2) {
      return Math.sqrt(Math.pow(val1, 2) + Math.pow(val2, 2))
    },
    /** 单张gif转静态图片 */
    gifToStaticImg(index) {
      return new Promise((resolve, reject) => {
        const gifImg = document.createElement('img');
        gifImg.src = this.enemySource[index].imgSource
        // gifImg.style.transform = 'rotate(90deg)';
        // 创建gif实例
        const rub = new SuperGif({ gif: gifImg } );
        rub.load(() => {
          const imgList = [];
          for (let i = 1; i <= rub.get_length(); i++) {
            // 遍历gif实例的每一帧
            rub.move_to(i);
            const imgUrl = rub.get_canvas()
            imgList.push(imgUrl)
          }
          this.enemySource[index].imgList = imgList
          resolve()
        });
      })
    },
    /** 等待所有的gif图生成静态图片 */
    async allGifToStaticImg() {
      return Promise.all(this.enemySource.map((item, index) => this.gifToStaticImg(index))).then(res => {})
    },
    /** 加载图片 imgUrl: 图片数组, objKey: 在数组中的key值  */
    loadImage(imgUrl, objKey) {
      return new Promise((resolve, reject) => {
        const imgObj = {}; // 保存图片资源
        let tempImg, imgLength = 0, loaded = 0;
        for (let key in imgUrl) {
          imgLength++; // 初始化要加载图片的总数
          tempImg = new Image();
          tempImg.src = !objKey ? imgUrl[key] : imgUrl[key][objKey];
          imgObj[key] = tempImg;
          tempImg.onload = function () {
            loaded++; // 统计已经加载完毕的图像
            // 所有的图片都加载完毕
            if (loaded >= imgLength) {
              resolve(imgObj)
            }
          };
        }
      })
    },
    /** 监听用户的键盘事件 */
    onKeyDown() {
      document.onkeydown = (e) => {
        switch (e.code) {
          case "Space": this.isPause = !this.isPause; break;
        }
      };
    },
  }
}
</script>

<style lang="less" scoped>
@size: 50px; 
#protect-horse {
  box-sizing: border-box;
  width: 100vw;
  height: 100vh;
  background-color: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  .game-wrap {
    position: relative;
    display: inline-block;
    // width: 1230px;
    padding: 30px;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid #eee;
    border-radius: 8px;
    .title {
      position: absolute;
      top: -50px;
      left: 0;
      right: 0;
      font-size: 24px;
      font-weight: bold;
      height: 30px;
      line-height: 30px;
      color: #ccc;
      text-align: center;
    }
    .canvas-wrap {
      position: relative;
      padding: 50px 50px 30px;
      background-image: radial-gradient(circle 500px at center, #16d9e3 0%, #30c7ec 47%, #46aef7 100%);
      border-radius: 4px;
      .building-wrap {
        position: absolute;
        user-select: none;
        .add-icon {
          width: @size;
          height: @size;
        }
        .tower-wrap {
          position: absolute;
          top: calc(@size + 6px);
          left: calc(50% - 120px);
          // 50 * 5 = 250
          width: calc(@size * 5 - 10px);
          display: flex;
          justify-content: space-between;
          flex-wrap: wrap;
          background: rgba(255, 255, 255, .3);
          border-radius: 16px;
          padding: 12px;
          .tower {
            position: relative;
            width: @size;
            height: @size;
            border-radius: 8px;
            border: 2px solid #fff;
            margin-bottom: 10px;
            box-sizing: border-box;
            .tower-icon {
              width: 100%;
              height: 100%;
            }
            .info {
              position: absolute;
              left: 0;
              right: 0;
              bottom: 0;
              text-align: center;
              font-size: 14px;
              color: #fff;
            }
          }
        }
      }
      .building-scope {
        position: absolute;
        transform: translate(-50%, -50%);
        box-sizing: border-box;
        border: 2px solid #3b9bdf;
        border-radius: 50%;
        background: rgba(255, 255, 255, .25);
      }
      .terminal {
        position: absolute;
        left: 20px;
        top: 45%;
        transform: translateY(-50%);
        user-select: none;
        .hp {
          color: #f24410;
          font-size: 18px;
          font-weight: bold;
          text-align: center;
        }
        .terminal-icon {
          width: 60px;
        }
      }
    }
  }
}
</style>
